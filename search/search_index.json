{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"pygdbmi - Get Structured Output from GDB's Machine Interface Documentation https://cs01.github.io/pygdbmi Source Code https://github.com/cs01/pygdbmi Python ( py ) gdb machine interface ( mi ) GDB/MI is a line based machine oriented text interface to GDB and is activated by specifying using the --interpreter command line option (see Mode Options). It is specifically intended to support the development of systems which use the debugger as just one small component of a larger system. What's in the box? A function to parse gdb machine interface string output and return structured data types (Python dicts) that are JSON serializable. Useful for writing the backend to a gdb frontend. For example, gdbgui uses pygdbmi on the backend. A Python class to control and interact with gdb as a subprocess To get machine interface output from gdb, run gdb with the --interpreter=mi2 flag like so: gdb --interpreter=mi2 Installation pip install pygdbmi Compatibility Operating Systems Cross platform support for Linux, macOS and Windows Linux/Unix Ubuntu 14.04 and 16.04 have been tested to work. Other versions likely work as well. macOS Note: the error please check gdb is codesigned - see taskgated(8) can be fixed by codesigning gdb with these instructions . If the error is not fixed, please create an issue in github . Windows Windows 10 has been tested to work with MinGW and cygwin. gdb versions gdb 7.6+ has been tested. Older versions may work as well. Examples gdb mi defines a syntax for its output that is suitable for machine readability and scripting: example output : -> - break - insert main <- ^ done , bkpt = { number = \"1\" , type = \"breakpoint\" , disp = \"keep\" , enabled = \"y\" , addr = \"0x08048564\" , func = \"main\" , file = \"myprog.c\" , fullname = \"/home/myprog.c\" , line = \"68\" , thread - groups = [ \"i1\" ], times = \"0\" } <- ( gdb ) Use pygdbmi.gdbmiparser.parse_response to turn that string output into a JSON serializable dictionary from pygdbmi import gdbmiparser from pprint import pprint response = gdbmiparser . parse_response ( '^done,bkpt={number=\"1\",type=\"breakpoint\",disp=\"keep\", enabled=\"y\",addr=\"0x08048564\",func=\"main\",file=\"myprog.c\",fullname=\"/home/myprog.c\",line=\"68\",thread-groups=[\"i1\"],times=\"0\"' ) pprint ( response ) > { 'message' : 'done' , 'payload' : { 'bkpt' : { 'addr' : '0x08048564' , 'disp' : 'keep' , 'enabled' : 'y' , 'file' : 'myprog.c' , 'fullname' : '/home/myprog.c' , 'func' : 'main' , 'line' : '68' , 'number' : '1' , 'thread-groups' : [ 'i1' ], 'times' : '0' , 'type' : 'breakpoint' }}, 'type' : 'result' } Programmatic Control Over gdb But how do you get the gdb output into Python in the first place? If you want, pygdbmi also has a class to control gdb as subprocess. You can write commands, and get structured output back: from pygdbmi.gdbcontroller import GdbController from pprint import pprint # Start gdb process gdbmi = GdbController () print ( gdbmi . get_subprocess_cmd ()) # print actual command run as subprocess # Load binary a.out and get structured response response = gdbmi . write ( '-file-exec-file a.out' ) pprint ( response ) [{ 'message' : u 'thread-group-added' , 'payload' : { u 'id' : u 'i1' }, 'type' : 'notify' }, { 'message' : u 'done' , 'payload' : None , 'type' : 'result' }] Now do whatever you want with gdb. All gdb commands, as well as gdb machine interface commands are acceptable. gdb mi commands give better structured output that is machine readable, rather than gdb console output. mi commands begin with a - . response = gdbmi . write ( '-break-insert main' ) # machine interface (MI) commands start with a '-' response = gdbmi . write ( 'break main' ) # normal gdb commands work too, but the return value is slightly different response = gdbmi . write ( '-exec-run' ) response = gdbmi . write ( 'run' ) response = gdbmi . write ( '-exec-next' , timeout_sec = 0.1 ) # the wait time can be modified from the default of 1 second response = gdbmi . write ( 'next' ) response = gdbmi . write ( 'next' , raise_error_on_timeout = False ) response = gdbmi . write ( 'next' , raise_error_on_timeout = True , timeout_sec = 0.01 ) response = gdbmi . write ( '-exec-continue' ) response = gdbmi . send_signal_to_gdb ( 'SIGKILL' ) # name of signal is okay response = gdbmi . send_signal_to_gdb ( 2 ) # value of signal is okay too response = gdbmi . interrupt_gdb () # sends SIGINT to gdb response = gdbmi . write ( 'continue' ) response = gdbmi . exit () Parsed Output Format Each parsed gdb response consists of a list of dictionaries. Each dictionary has keys message , payload , token , and type . message contains a textual message from gdb, which is not always present. When missing, this is None . payload contains the content of gdb's output, which can contain any of the following: dictionary , list , string . This too is not always present, and can be None depending on the response. token If an input command was prefixed with a (optional) token then the corresponding output for that command will also be prefixed by that same token. This field is only present for pygdbmi output types nofity and result . When missing, this is None . The type is defined based on gdb's various mi output record types , and can be result - the result of a gdb command, such as done , running , error , etc. notify - additional async changes that have occurred, such as breakpoint modified console - textual responses to cli commands log - debugging messages from gdb's internals output - output from target target - output from remote target done - when gdb has finished its output Contributing Documentation fixes, bug fixes, performance improvements, and functional improvements are welcome. You may want to create an issue before beginning work to make sure I am interested in merging it to the master branch. pygdbmi uses nox for automation. See available tasks with nox -l Run tests and lint with nox -s tests nox -s lint Projects Using pygdbmi gdbgui implements a browser-based frontend to gdb, using pygdbmi on the backend PINCE is a gdb frontend that aims to provide a reverse engineering tool and a reusable library focused on games. It uses pygdbmi to parse gdb/mi based output for some functions avatar\u00b2 is an orchestration framework for reversing and analysing firmware of embedded devices. It utilizes pygdbmi for internal communication to different analysis targets. Know of another project? Create a PR and add it here. Authors Chad Smith (main author and creator). Marco Barisione (co-maintainer). The community . Thanks especially to @mariusmue, @bobthekingofegypt, @mouuff, and @felipesere.","title":"Home"},{"location":"#whats-in-the-box","text":"A function to parse gdb machine interface string output and return structured data types (Python dicts) that are JSON serializable. Useful for writing the backend to a gdb frontend. For example, gdbgui uses pygdbmi on the backend. A Python class to control and interact with gdb as a subprocess To get machine interface output from gdb, run gdb with the --interpreter=mi2 flag like so: gdb --interpreter=mi2","title":"What's in the box?"},{"location":"#installation","text":"pip install pygdbmi","title":"Installation"},{"location":"#compatibility","text":"","title":"Compatibility"},{"location":"#operating-systems","text":"Cross platform support for Linux, macOS and Windows Linux/Unix Ubuntu 14.04 and 16.04 have been tested to work. Other versions likely work as well. macOS Note: the error please check gdb is codesigned - see taskgated(8) can be fixed by codesigning gdb with these instructions . If the error is not fixed, please create an issue in github . Windows Windows 10 has been tested to work with MinGW and cygwin.","title":"Operating Systems"},{"location":"#gdb-versions","text":"gdb 7.6+ has been tested. Older versions may work as well.","title":"gdb versions"},{"location":"#examples","text":"gdb mi defines a syntax for its output that is suitable for machine readability and scripting: example output : -> - break - insert main <- ^ done , bkpt = { number = \"1\" , type = \"breakpoint\" , disp = \"keep\" , enabled = \"y\" , addr = \"0x08048564\" , func = \"main\" , file = \"myprog.c\" , fullname = \"/home/myprog.c\" , line = \"68\" , thread - groups = [ \"i1\" ], times = \"0\" } <- ( gdb ) Use pygdbmi.gdbmiparser.parse_response to turn that string output into a JSON serializable dictionary from pygdbmi import gdbmiparser from pprint import pprint response = gdbmiparser . parse_response ( '^done,bkpt={number=\"1\",type=\"breakpoint\",disp=\"keep\", enabled=\"y\",addr=\"0x08048564\",func=\"main\",file=\"myprog.c\",fullname=\"/home/myprog.c\",line=\"68\",thread-groups=[\"i1\"],times=\"0\"' ) pprint ( response ) > { 'message' : 'done' , 'payload' : { 'bkpt' : { 'addr' : '0x08048564' , 'disp' : 'keep' , 'enabled' : 'y' , 'file' : 'myprog.c' , 'fullname' : '/home/myprog.c' , 'func' : 'main' , 'line' : '68' , 'number' : '1' , 'thread-groups' : [ 'i1' ], 'times' : '0' , 'type' : 'breakpoint' }}, 'type' : 'result' }","title":"Examples"},{"location":"#programmatic-control-over-gdb","text":"But how do you get the gdb output into Python in the first place? If you want, pygdbmi also has a class to control gdb as subprocess. You can write commands, and get structured output back: from pygdbmi.gdbcontroller import GdbController from pprint import pprint # Start gdb process gdbmi = GdbController () print ( gdbmi . get_subprocess_cmd ()) # print actual command run as subprocess # Load binary a.out and get structured response response = gdbmi . write ( '-file-exec-file a.out' ) pprint ( response ) [{ 'message' : u 'thread-group-added' , 'payload' : { u 'id' : u 'i1' }, 'type' : 'notify' }, { 'message' : u 'done' , 'payload' : None , 'type' : 'result' }] Now do whatever you want with gdb. All gdb commands, as well as gdb machine interface commands are acceptable. gdb mi commands give better structured output that is machine readable, rather than gdb console output. mi commands begin with a - . response = gdbmi . write ( '-break-insert main' ) # machine interface (MI) commands start with a '-' response = gdbmi . write ( 'break main' ) # normal gdb commands work too, but the return value is slightly different response = gdbmi . write ( '-exec-run' ) response = gdbmi . write ( 'run' ) response = gdbmi . write ( '-exec-next' , timeout_sec = 0.1 ) # the wait time can be modified from the default of 1 second response = gdbmi . write ( 'next' ) response = gdbmi . write ( 'next' , raise_error_on_timeout = False ) response = gdbmi . write ( 'next' , raise_error_on_timeout = True , timeout_sec = 0.01 ) response = gdbmi . write ( '-exec-continue' ) response = gdbmi . send_signal_to_gdb ( 'SIGKILL' ) # name of signal is okay response = gdbmi . send_signal_to_gdb ( 2 ) # value of signal is okay too response = gdbmi . interrupt_gdb () # sends SIGINT to gdb response = gdbmi . write ( 'continue' ) response = gdbmi . exit ()","title":"Programmatic Control Over gdb"},{"location":"#parsed-output-format","text":"Each parsed gdb response consists of a list of dictionaries. Each dictionary has keys message , payload , token , and type . message contains a textual message from gdb, which is not always present. When missing, this is None . payload contains the content of gdb's output, which can contain any of the following: dictionary , list , string . This too is not always present, and can be None depending on the response. token If an input command was prefixed with a (optional) token then the corresponding output for that command will also be prefixed by that same token. This field is only present for pygdbmi output types nofity and result . When missing, this is None . The type is defined based on gdb's various mi output record types , and can be result - the result of a gdb command, such as done , running , error , etc. notify - additional async changes that have occurred, such as breakpoint modified console - textual responses to cli commands log - debugging messages from gdb's internals output - output from target target - output from remote target done - when gdb has finished its output","title":"Parsed Output Format"},{"location":"#contributing","text":"Documentation fixes, bug fixes, performance improvements, and functional improvements are welcome. You may want to create an issue before beginning work to make sure I am interested in merging it to the master branch. pygdbmi uses nox for automation. See available tasks with nox -l Run tests and lint with nox -s tests nox -s lint","title":"Contributing"},{"location":"#projects-using-pygdbmi","text":"gdbgui implements a browser-based frontend to gdb, using pygdbmi on the backend PINCE is a gdb frontend that aims to provide a reverse engineering tool and a reusable library focused on games. It uses pygdbmi to parse gdb/mi based output for some functions avatar\u00b2 is an orchestration framework for reversing and analysing firmware of embedded devices. It utilizes pygdbmi for internal communication to different analysis targets. Know of another project? Create a PR and add it here.","title":"Projects Using pygdbmi"},{"location":"#authors","text":"Chad Smith (main author and creator). Marco Barisione (co-maintainer). The community . Thanks especially to @mariusmue, @bobthekingofegypt, @mouuff, and @felipesere.","title":"Authors"},{"location":"CHANGELOG/","text":"pygdbmi release history 0.10.0.2 Strings containing escapes are now unescaped, both for messages in error records, which were previously mangled (#57), and textual records, which were previously left escaped (#58) Dropped support for Python 3.6 and added explicit support for Python 3.9 and 3.10. 0.10.0.1 Fix bug with time_to_check_for_additional_output_sec , as it was not being used when passed to GdbController 0.10.0.0 Breaking Changes Drop support for Python 3.5 Update GdbController() API. New API is GdbController(command: Optional[List[str]], time_to_check_for_additional_output_sec: Optional[int]) . GdbController.verify_valid_gdb_subprocess() was removed Remove NoGdbProcessError error Other Changes Add new IoManager class to handle more generic use-cases [dev] use pytest for testing gdb mi parsing remains unchanged 0.9.0.3 Drop support for 2.7, 3.4 Add support for 3.7, 3.8 Add py.typed file so mypy can enforce type hints on pygdbmi Do not log in StringStream (#36) Updates to build and CI tests (use nox) Use mkdocs and mkdocstrings Doc updates 0.9.0.2 More doc updates 0.9.0.1 Update docs 0.9.0.0 Stop buffering output Use logger in GdbController; modify verbose arguments. Remove support for Python 3.3 0.8.4.0 Add method get_subprocess_cmd to view the gdb command run in the shell 0.8.3.0 Improve reading gdb responses on unix (performance, bugfix) (@mouuff) 0.8.2.0 Add support for record and replay (rr) gdb supplement 0.8.1.1 Discard unexpected text from gdb 0.8.1.0 Add native Windows support 0.8.0.0 Make parsing more efficient when gdb outputs large strings Add new methods to GdbController class: spawn_new_gdb_subprocess , send_signal_to_gdb , and interrupt_gdb 0.7.4.5 Update setup.py 0.7.4.4 Fix windows ctypes import (#23, @rudolfwalter) 0.7.4.3 Workaround gdb bug with repeated dictionary keys 0.7.4.2 Improved buffering of incomplete gdb mi output (@trapito) Remove support of Python 3.2 0.7.4.1 Preserve leading and trailing spaces in gdb/mi output (plus unit tests) Add unit test for buffering of gdb/mi output Documentation updates Refactoring 0.7.4.0 Add more exception types ( NoGdbProcessError , GdbTimeoutError ) Add logic fixes for Windows (@johncf) Use codecs.open() to open the readme.rst, to prevent locale related bugs (@mariusmue) 0.7.3.3 Add alternate pipe implementation for Windows 0.7.3.2 Replace epoll with select for osx compatibility (@felipesere) 0.7.3.1 Fix README 0.7.3.0 Add support for gdb/mi (optional) tokens (@mariusmue)","title":"Changelog"},{"location":"CHANGELOG/#pygdbmi-release-history","text":"","title":"pygdbmi release history"},{"location":"CHANGELOG/#01002","text":"Strings containing escapes are now unescaped, both for messages in error records, which were previously mangled (#57), and textual records, which were previously left escaped (#58) Dropped support for Python 3.6 and added explicit support for Python 3.9 and 3.10.","title":"0.10.0.2"},{"location":"CHANGELOG/#01001","text":"Fix bug with time_to_check_for_additional_output_sec , as it was not being used when passed to GdbController","title":"0.10.0.1"},{"location":"CHANGELOG/#01000","text":"Breaking Changes Drop support for Python 3.5 Update GdbController() API. New API is GdbController(command: Optional[List[str]], time_to_check_for_additional_output_sec: Optional[int]) . GdbController.verify_valid_gdb_subprocess() was removed Remove NoGdbProcessError error Other Changes Add new IoManager class to handle more generic use-cases [dev] use pytest for testing gdb mi parsing remains unchanged","title":"0.10.0.0"},{"location":"CHANGELOG/#0903","text":"Drop support for 2.7, 3.4 Add support for 3.7, 3.8 Add py.typed file so mypy can enforce type hints on pygdbmi Do not log in StringStream (#36) Updates to build and CI tests (use nox) Use mkdocs and mkdocstrings Doc updates","title":"0.9.0.3"},{"location":"CHANGELOG/#0902","text":"More doc updates","title":"0.9.0.2"},{"location":"CHANGELOG/#0901","text":"Update docs","title":"0.9.0.1"},{"location":"CHANGELOG/#0900","text":"Stop buffering output Use logger in GdbController; modify verbose arguments. Remove support for Python 3.3","title":"0.9.0.0"},{"location":"CHANGELOG/#0840","text":"Add method get_subprocess_cmd to view the gdb command run in the shell","title":"0.8.4.0"},{"location":"CHANGELOG/#0830","text":"Improve reading gdb responses on unix (performance, bugfix) (@mouuff)","title":"0.8.3.0"},{"location":"CHANGELOG/#0820","text":"Add support for record and replay (rr) gdb supplement","title":"0.8.2.0"},{"location":"CHANGELOG/#0811","text":"Discard unexpected text from gdb","title":"0.8.1.1"},{"location":"CHANGELOG/#0810","text":"Add native Windows support","title":"0.8.1.0"},{"location":"CHANGELOG/#0800","text":"Make parsing more efficient when gdb outputs large strings Add new methods to GdbController class: spawn_new_gdb_subprocess , send_signal_to_gdb , and interrupt_gdb","title":"0.8.0.0"},{"location":"CHANGELOG/#0745","text":"Update setup.py","title":"0.7.4.5"},{"location":"CHANGELOG/#0744","text":"Fix windows ctypes import (#23, @rudolfwalter)","title":"0.7.4.4"},{"location":"CHANGELOG/#0743","text":"Workaround gdb bug with repeated dictionary keys","title":"0.7.4.3"},{"location":"CHANGELOG/#0742","text":"Improved buffering of incomplete gdb mi output (@trapito) Remove support of Python 3.2","title":"0.7.4.2"},{"location":"CHANGELOG/#0741","text":"Preserve leading and trailing spaces in gdb/mi output (plus unit tests) Add unit test for buffering of gdb/mi output Documentation updates Refactoring","title":"0.7.4.1"},{"location":"CHANGELOG/#0740","text":"Add more exception types ( NoGdbProcessError , GdbTimeoutError ) Add logic fixes for Windows (@johncf) Use codecs.open() to open the readme.rst, to prevent locale related bugs (@mariusmue)","title":"0.7.4.0"},{"location":"CHANGELOG/#0733","text":"Add alternate pipe implementation for Windows","title":"0.7.3.3"},{"location":"CHANGELOG/#0732","text":"Replace epoll with select for osx compatibility (@felipesere)","title":"0.7.3.2"},{"location":"CHANGELOG/#0731","text":"Fix README","title":"0.7.3.1"},{"location":"CHANGELOG/#0730","text":"Add support for gdb/mi (optional) tokens (@mariusmue)","title":"0.7.3.0"},{"location":"api/gdbcontroller/","text":"This module defines the GdbController class which runs gdb as a subprocess and can write to it and read from it to get structured output. GdbController Source code in pygdbmi/gdbcontroller.py class GdbController : def __init__ ( self , command : Optional [ List [ str ]] = None , time_to_check_for_additional_output_sec = DEFAULT_TIME_TO_CHECK_FOR_ADDITIONAL_OUTPUT_SEC , ): \"\"\" Run gdb as a subprocess. Send commands and receive structured output. Create new object, along with a gdb subprocess Args: command: Command to run in shell to spawn new gdb subprocess time_to_check_for_additional_output_sec: When parsing responses, wait this amout of time before exiting (exits before timeout is reached to save time). If <= 0, full timeout time is used. Returns: New GdbController object \"\"\" if command is None : command = DEFAULT_GDB_LAUNCH_COMMAND if not any ([( \"--interpreter=mi\" in c ) for c in command ]): logger . warning ( \"Adding `--interpreter=mi3` (or similar) is recommended to get structured output. \" + \"See https://sourceware.org/gdb/onlinedocs/gdb/Mode-Options.html#Mode-Options.\" ) self . abs_gdb_path = None # abs path to gdb executable self . command = command # type: List[str] self . time_to_check_for_additional_output_sec = ( time_to_check_for_additional_output_sec ) self . gdb_process = None self . _allow_overwrite_timeout_times = ( self . time_to_check_for_additional_output_sec > 0 ) gdb_path = command [ 0 ] if not gdb_path : raise ValueError ( \"a valid path to gdb must be specified\" ) else : abs_gdb_path = find_executable ( gdb_path ) if abs_gdb_path is None : raise ValueError ( 'gdb executable could not be resolved from \" %s \"' % gdb_path ) else : self . abs_gdb_path = abs_gdb_path self . spawn_new_gdb_subprocess () def spawn_new_gdb_subprocess ( self ): \"\"\"Spawn a new gdb subprocess with the arguments supplied to the object during initialization. If gdb subprocess already exists, terminate it before spanwing a new one. Return int: gdb process id \"\"\" if self . gdb_process : logger . debug ( \"Killing current gdb subprocess (pid %d )\" % self . gdb_process . pid ) self . exit () logger . debug ( f 'Launching gdb: { \" \" . join ( self . command ) } ' ) # Use pipes to the standard streams self . gdb_process = subprocess . Popen ( self . command , shell = False , stdout = subprocess . PIPE , stdin = subprocess . PIPE , stderr = subprocess . PIPE , bufsize = 0 , ) self . io_manager = IoManager ( self . gdb_process . stdin , self . gdb_process . stdout , self . gdb_process . stderr , self . time_to_check_for_additional_output_sec , ) return self . gdb_process . pid def get_gdb_response ( self , timeout_sec : float = DEFAULT_GDB_TIMEOUT_SEC , raise_error_on_timeout = True ): \"\"\"Get gdb response. See IoManager.get_gdb_response() for details\"\"\" return self . io_manager . get_gdb_response ( timeout_sec , raise_error_on_timeout ) def write ( self , mi_cmd_to_write : Union [ str , List [ str ]], timeout_sec = DEFAULT_GDB_TIMEOUT_SEC , raise_error_on_timeout : bool = True , read_response : bool = True , ): \"\"\"Write command to gdb. See IoManager.write() for details\"\"\" return self . io_manager . write ( mi_cmd_to_write , timeout_sec , raise_error_on_timeout , read_response ) def exit ( self ) -> None : \"\"\"Terminate gdb process\"\"\" if self . gdb_process : self . gdb_process . terminate () self . gdb_process . communicate () self . gdb_process = None return None __init__ ( self , command = None , time_to_check_for_additional_output_sec = 0.2 ) special Run gdb as a subprocess. Send commands and receive structured output. Create new object, along with a gdb subprocess Parameters: Name Type Description Default command Optional[List[str]] Command to run in shell to spawn new gdb subprocess None time_to_check_for_additional_output_sec When parsing responses, wait this amout of time before exiting (exits before timeout is reached to save time). If <= 0, full timeout time is used. 0.2 Returns: Type Description New GdbController object Source code in pygdbmi/gdbcontroller.py def __init__ ( self , command : Optional [ List [ str ]] = None , time_to_check_for_additional_output_sec = DEFAULT_TIME_TO_CHECK_FOR_ADDITIONAL_OUTPUT_SEC , ): \"\"\" Run gdb as a subprocess. Send commands and receive structured output. Create new object, along with a gdb subprocess Args: command: Command to run in shell to spawn new gdb subprocess time_to_check_for_additional_output_sec: When parsing responses, wait this amout of time before exiting (exits before timeout is reached to save time). If <= 0, full timeout time is used. Returns: New GdbController object \"\"\" if command is None : command = DEFAULT_GDB_LAUNCH_COMMAND if not any ([( \"--interpreter=mi\" in c ) for c in command ]): logger . warning ( \"Adding `--interpreter=mi3` (or similar) is recommended to get structured output. \" + \"See https://sourceware.org/gdb/onlinedocs/gdb/Mode-Options.html#Mode-Options.\" ) self . abs_gdb_path = None # abs path to gdb executable self . command = command # type: List[str] self . time_to_check_for_additional_output_sec = ( time_to_check_for_additional_output_sec ) self . gdb_process = None self . _allow_overwrite_timeout_times = ( self . time_to_check_for_additional_output_sec > 0 ) gdb_path = command [ 0 ] if not gdb_path : raise ValueError ( \"a valid path to gdb must be specified\" ) else : abs_gdb_path = find_executable ( gdb_path ) if abs_gdb_path is None : raise ValueError ( 'gdb executable could not be resolved from \" %s \"' % gdb_path ) else : self . abs_gdb_path = abs_gdb_path self . spawn_new_gdb_subprocess () exit ( self ) Terminate gdb process Source code in pygdbmi/gdbcontroller.py def exit ( self ) -> None : \"\"\"Terminate gdb process\"\"\" if self . gdb_process : self . gdb_process . terminate () self . gdb_process . communicate () self . gdb_process = None return None get_gdb_response ( self , timeout_sec = 1 , raise_error_on_timeout = True ) Get gdb response. See IoManager.get_gdb_response() for details Source code in pygdbmi/gdbcontroller.py def get_gdb_response ( self , timeout_sec : float = DEFAULT_GDB_TIMEOUT_SEC , raise_error_on_timeout = True ): \"\"\"Get gdb response. See IoManager.get_gdb_response() for details\"\"\" return self . io_manager . get_gdb_response ( timeout_sec , raise_error_on_timeout ) spawn_new_gdb_subprocess ( self ) Spawn a new gdb subprocess with the arguments supplied to the object during initialization. If gdb subprocess already exists, terminate it before spanwing a new one. Return int: gdb process id Source code in pygdbmi/gdbcontroller.py def spawn_new_gdb_subprocess ( self ): \"\"\"Spawn a new gdb subprocess with the arguments supplied to the object during initialization. If gdb subprocess already exists, terminate it before spanwing a new one. Return int: gdb process id \"\"\" if self . gdb_process : logger . debug ( \"Killing current gdb subprocess (pid %d )\" % self . gdb_process . pid ) self . exit () logger . debug ( f 'Launching gdb: { \" \" . join ( self . command ) } ' ) # Use pipes to the standard streams self . gdb_process = subprocess . Popen ( self . command , shell = False , stdout = subprocess . PIPE , stdin = subprocess . PIPE , stderr = subprocess . PIPE , bufsize = 0 , ) self . io_manager = IoManager ( self . gdb_process . stdin , self . gdb_process . stdout , self . gdb_process . stderr , self . time_to_check_for_additional_output_sec , ) return self . gdb_process . pid write ( self , mi_cmd_to_write , timeout_sec = 1 , raise_error_on_timeout = True , read_response = True ) Write command to gdb. See IoManager.write() for details Source code in pygdbmi/gdbcontroller.py def write ( self , mi_cmd_to_write : Union [ str , List [ str ]], timeout_sec = DEFAULT_GDB_TIMEOUT_SEC , raise_error_on_timeout : bool = True , read_response : bool = True , ): \"\"\"Write command to gdb. See IoManager.write() for details\"\"\" return self . io_manager . write ( mi_cmd_to_write , timeout_sec , raise_error_on_timeout , read_response )","title":"gdbcontroller"},{"location":"api/gdbcontroller/#pygdbmi.gdbcontroller.GdbController","text":"Source code in pygdbmi/gdbcontroller.py class GdbController : def __init__ ( self , command : Optional [ List [ str ]] = None , time_to_check_for_additional_output_sec = DEFAULT_TIME_TO_CHECK_FOR_ADDITIONAL_OUTPUT_SEC , ): \"\"\" Run gdb as a subprocess. Send commands and receive structured output. Create new object, along with a gdb subprocess Args: command: Command to run in shell to spawn new gdb subprocess time_to_check_for_additional_output_sec: When parsing responses, wait this amout of time before exiting (exits before timeout is reached to save time). If <= 0, full timeout time is used. Returns: New GdbController object \"\"\" if command is None : command = DEFAULT_GDB_LAUNCH_COMMAND if not any ([( \"--interpreter=mi\" in c ) for c in command ]): logger . warning ( \"Adding `--interpreter=mi3` (or similar) is recommended to get structured output. \" + \"See https://sourceware.org/gdb/onlinedocs/gdb/Mode-Options.html#Mode-Options.\" ) self . abs_gdb_path = None # abs path to gdb executable self . command = command # type: List[str] self . time_to_check_for_additional_output_sec = ( time_to_check_for_additional_output_sec ) self . gdb_process = None self . _allow_overwrite_timeout_times = ( self . time_to_check_for_additional_output_sec > 0 ) gdb_path = command [ 0 ] if not gdb_path : raise ValueError ( \"a valid path to gdb must be specified\" ) else : abs_gdb_path = find_executable ( gdb_path ) if abs_gdb_path is None : raise ValueError ( 'gdb executable could not be resolved from \" %s \"' % gdb_path ) else : self . abs_gdb_path = abs_gdb_path self . spawn_new_gdb_subprocess () def spawn_new_gdb_subprocess ( self ): \"\"\"Spawn a new gdb subprocess with the arguments supplied to the object during initialization. If gdb subprocess already exists, terminate it before spanwing a new one. Return int: gdb process id \"\"\" if self . gdb_process : logger . debug ( \"Killing current gdb subprocess (pid %d )\" % self . gdb_process . pid ) self . exit () logger . debug ( f 'Launching gdb: { \" \" . join ( self . command ) } ' ) # Use pipes to the standard streams self . gdb_process = subprocess . Popen ( self . command , shell = False , stdout = subprocess . PIPE , stdin = subprocess . PIPE , stderr = subprocess . PIPE , bufsize = 0 , ) self . io_manager = IoManager ( self . gdb_process . stdin , self . gdb_process . stdout , self . gdb_process . stderr , self . time_to_check_for_additional_output_sec , ) return self . gdb_process . pid def get_gdb_response ( self , timeout_sec : float = DEFAULT_GDB_TIMEOUT_SEC , raise_error_on_timeout = True ): \"\"\"Get gdb response. See IoManager.get_gdb_response() for details\"\"\" return self . io_manager . get_gdb_response ( timeout_sec , raise_error_on_timeout ) def write ( self , mi_cmd_to_write : Union [ str , List [ str ]], timeout_sec = DEFAULT_GDB_TIMEOUT_SEC , raise_error_on_timeout : bool = True , read_response : bool = True , ): \"\"\"Write command to gdb. See IoManager.write() for details\"\"\" return self . io_manager . write ( mi_cmd_to_write , timeout_sec , raise_error_on_timeout , read_response ) def exit ( self ) -> None : \"\"\"Terminate gdb process\"\"\" if self . gdb_process : self . gdb_process . terminate () self . gdb_process . communicate () self . gdb_process = None return None","title":"GdbController"},{"location":"api/gdbcontroller/#pygdbmi.gdbcontroller.GdbController.__init__","text":"Run gdb as a subprocess. Send commands and receive structured output. Create new object, along with a gdb subprocess Parameters: Name Type Description Default command Optional[List[str]] Command to run in shell to spawn new gdb subprocess None time_to_check_for_additional_output_sec When parsing responses, wait this amout of time before exiting (exits before timeout is reached to save time). If <= 0, full timeout time is used. 0.2 Returns: Type Description New GdbController object Source code in pygdbmi/gdbcontroller.py def __init__ ( self , command : Optional [ List [ str ]] = None , time_to_check_for_additional_output_sec = DEFAULT_TIME_TO_CHECK_FOR_ADDITIONAL_OUTPUT_SEC , ): \"\"\" Run gdb as a subprocess. Send commands and receive structured output. Create new object, along with a gdb subprocess Args: command: Command to run in shell to spawn new gdb subprocess time_to_check_for_additional_output_sec: When parsing responses, wait this amout of time before exiting (exits before timeout is reached to save time). If <= 0, full timeout time is used. Returns: New GdbController object \"\"\" if command is None : command = DEFAULT_GDB_LAUNCH_COMMAND if not any ([( \"--interpreter=mi\" in c ) for c in command ]): logger . warning ( \"Adding `--interpreter=mi3` (or similar) is recommended to get structured output. \" + \"See https://sourceware.org/gdb/onlinedocs/gdb/Mode-Options.html#Mode-Options.\" ) self . abs_gdb_path = None # abs path to gdb executable self . command = command # type: List[str] self . time_to_check_for_additional_output_sec = ( time_to_check_for_additional_output_sec ) self . gdb_process = None self . _allow_overwrite_timeout_times = ( self . time_to_check_for_additional_output_sec > 0 ) gdb_path = command [ 0 ] if not gdb_path : raise ValueError ( \"a valid path to gdb must be specified\" ) else : abs_gdb_path = find_executable ( gdb_path ) if abs_gdb_path is None : raise ValueError ( 'gdb executable could not be resolved from \" %s \"' % gdb_path ) else : self . abs_gdb_path = abs_gdb_path self . spawn_new_gdb_subprocess ()","title":"__init__()"},{"location":"api/gdbcontroller/#pygdbmi.gdbcontroller.GdbController.exit","text":"Terminate gdb process Source code in pygdbmi/gdbcontroller.py def exit ( self ) -> None : \"\"\"Terminate gdb process\"\"\" if self . gdb_process : self . gdb_process . terminate () self . gdb_process . communicate () self . gdb_process = None return None","title":"exit()"},{"location":"api/gdbcontroller/#pygdbmi.gdbcontroller.GdbController.get_gdb_response","text":"Get gdb response. See IoManager.get_gdb_response() for details Source code in pygdbmi/gdbcontroller.py def get_gdb_response ( self , timeout_sec : float = DEFAULT_GDB_TIMEOUT_SEC , raise_error_on_timeout = True ): \"\"\"Get gdb response. See IoManager.get_gdb_response() for details\"\"\" return self . io_manager . get_gdb_response ( timeout_sec , raise_error_on_timeout )","title":"get_gdb_response()"},{"location":"api/gdbcontroller/#pygdbmi.gdbcontroller.GdbController.spawn_new_gdb_subprocess","text":"Spawn a new gdb subprocess with the arguments supplied to the object during initialization. If gdb subprocess already exists, terminate it before spanwing a new one. Return int: gdb process id Source code in pygdbmi/gdbcontroller.py def spawn_new_gdb_subprocess ( self ): \"\"\"Spawn a new gdb subprocess with the arguments supplied to the object during initialization. If gdb subprocess already exists, terminate it before spanwing a new one. Return int: gdb process id \"\"\" if self . gdb_process : logger . debug ( \"Killing current gdb subprocess (pid %d )\" % self . gdb_process . pid ) self . exit () logger . debug ( f 'Launching gdb: { \" \" . join ( self . command ) } ' ) # Use pipes to the standard streams self . gdb_process = subprocess . Popen ( self . command , shell = False , stdout = subprocess . PIPE , stdin = subprocess . PIPE , stderr = subprocess . PIPE , bufsize = 0 , ) self . io_manager = IoManager ( self . gdb_process . stdin , self . gdb_process . stdout , self . gdb_process . stderr , self . time_to_check_for_additional_output_sec , ) return self . gdb_process . pid","title":"spawn_new_gdb_subprocess()"},{"location":"api/gdbcontroller/#pygdbmi.gdbcontroller.GdbController.write","text":"Write command to gdb. See IoManager.write() for details Source code in pygdbmi/gdbcontroller.py def write ( self , mi_cmd_to_write : Union [ str , List [ str ]], timeout_sec = DEFAULT_GDB_TIMEOUT_SEC , raise_error_on_timeout : bool = True , read_response : bool = True , ): \"\"\"Write command to gdb. See IoManager.write() for details\"\"\" return self . io_manager . write ( mi_cmd_to_write , timeout_sec , raise_error_on_timeout , read_response )","title":"write()"},{"location":"api/gdbmiparser/","text":"Python parser for gdb's machine interface interpreter. Parses string output from gdb with the --interpreter=mi2 flag into structured objects. See more at https://sourceware.org/gdb/onlinedocs/gdb/GDB_002fMI.html#GDB_002fMI parse_response ( gdb_mi_text ) Parse gdb mi text and turn it into a dictionary. See https://sourceware.org/gdb/onlinedocs/gdb/GDB_002fMI-Stream-Records.html#GDB_002fMI-Stream-Records for details on types of gdb mi output. Parameters: Name Type Description Default gdb_mi_text str String output from gdb required Returns: Type Description Dict dictionary with keys \"type\", \"message\", \"payload\", \"token\" Source code in pygdbmi/gdbmiparser.py def parse_response ( gdb_mi_text : str ) -> Dict : \"\"\"Parse gdb mi text and turn it into a dictionary. See https://sourceware.org/gdb/onlinedocs/gdb/GDB_002fMI-Stream-Records.html#GDB_002fMI-Stream-Records for details on types of gdb mi output. Args: gdb_mi_text: String output from gdb Returns: dictionary with keys \"type\", \"message\", \"payload\", \"token\" \"\"\" stream = StringStream ( gdb_mi_text , debug = _DEBUG ) if _GDB_MI_NOTIFY_RE . match ( gdb_mi_text ): token , message , payload = _get_notify_msg_and_payload ( gdb_mi_text , stream ) return { \"type\" : \"notify\" , \"message\" : message , \"payload\" : payload , \"token\" : token , } elif _GDB_MI_RESULT_RE . match ( gdb_mi_text ): token , message , payload = _get_result_msg_and_payload ( gdb_mi_text , stream ) return { \"type\" : \"result\" , \"message\" : message , \"payload\" : payload , \"token\" : token , } elif _GDB_MI_CONSOLE_RE . match ( gdb_mi_text ): match = _GDB_MI_CONSOLE_RE . match ( gdb_mi_text ) if match : payload = unescape ( match . groups ()[ 0 ]) else : payload = None return { \"type\" : \"console\" , \"message\" : None , \"payload\" : payload , } elif _GDB_MI_LOG_RE . match ( gdb_mi_text ): match = _GDB_MI_LOG_RE . match ( gdb_mi_text ) if match : payload = unescape ( match . groups ()[ 0 ]) else : payload = None return { \"type\" : \"log\" , \"message\" : None , \"payload\" : payload } elif _GDB_MI_TARGET_OUTPUT_RE . match ( gdb_mi_text ): match = _GDB_MI_TARGET_OUTPUT_RE . match ( gdb_mi_text ) if match : payload = unescape ( match . groups ()[ 0 ]) else : payload = None return { \"type\" : \"target\" , \"message\" : None , \"payload\" : payload } elif response_is_finished ( gdb_mi_text ): return { \"type\" : \"done\" , \"message\" : None , \"payload\" : None } else : # This was not gdb mi output, so it must have just been printed by # the inferior program that's being debugged return { \"type\" : \"output\" , \"message\" : None , \"payload\" : gdb_mi_text } response_is_finished ( gdb_mi_text ) Return true if the gdb mi response is ending Parameters: Name Type Description Default gdb_mi_text str String output from gdb required Returns: Type Description bool True if gdb response is finished Source code in pygdbmi/gdbmiparser.py def response_is_finished ( gdb_mi_text : str ) -> bool : \"\"\"Return true if the gdb mi response is ending Args: gdb_mi_text: String output from gdb Returns: True if gdb response is finished \"\"\" if _GDB_MI_RESPONSE_FINISHED_RE . match ( gdb_mi_text ): return True else : return False","title":"gdbmiparser"},{"location":"api/gdbmiparser/#pygdbmi.gdbmiparser.parse_response","text":"Parse gdb mi text and turn it into a dictionary. See https://sourceware.org/gdb/onlinedocs/gdb/GDB_002fMI-Stream-Records.html#GDB_002fMI-Stream-Records for details on types of gdb mi output. Parameters: Name Type Description Default gdb_mi_text str String output from gdb required Returns: Type Description Dict dictionary with keys \"type\", \"message\", \"payload\", \"token\" Source code in pygdbmi/gdbmiparser.py def parse_response ( gdb_mi_text : str ) -> Dict : \"\"\"Parse gdb mi text and turn it into a dictionary. See https://sourceware.org/gdb/onlinedocs/gdb/GDB_002fMI-Stream-Records.html#GDB_002fMI-Stream-Records for details on types of gdb mi output. Args: gdb_mi_text: String output from gdb Returns: dictionary with keys \"type\", \"message\", \"payload\", \"token\" \"\"\" stream = StringStream ( gdb_mi_text , debug = _DEBUG ) if _GDB_MI_NOTIFY_RE . match ( gdb_mi_text ): token , message , payload = _get_notify_msg_and_payload ( gdb_mi_text , stream ) return { \"type\" : \"notify\" , \"message\" : message , \"payload\" : payload , \"token\" : token , } elif _GDB_MI_RESULT_RE . match ( gdb_mi_text ): token , message , payload = _get_result_msg_and_payload ( gdb_mi_text , stream ) return { \"type\" : \"result\" , \"message\" : message , \"payload\" : payload , \"token\" : token , } elif _GDB_MI_CONSOLE_RE . match ( gdb_mi_text ): match = _GDB_MI_CONSOLE_RE . match ( gdb_mi_text ) if match : payload = unescape ( match . groups ()[ 0 ]) else : payload = None return { \"type\" : \"console\" , \"message\" : None , \"payload\" : payload , } elif _GDB_MI_LOG_RE . match ( gdb_mi_text ): match = _GDB_MI_LOG_RE . match ( gdb_mi_text ) if match : payload = unescape ( match . groups ()[ 0 ]) else : payload = None return { \"type\" : \"log\" , \"message\" : None , \"payload\" : payload } elif _GDB_MI_TARGET_OUTPUT_RE . match ( gdb_mi_text ): match = _GDB_MI_TARGET_OUTPUT_RE . match ( gdb_mi_text ) if match : payload = unescape ( match . groups ()[ 0 ]) else : payload = None return { \"type\" : \"target\" , \"message\" : None , \"payload\" : payload } elif response_is_finished ( gdb_mi_text ): return { \"type\" : \"done\" , \"message\" : None , \"payload\" : None } else : # This was not gdb mi output, so it must have just been printed by # the inferior program that's being debugged return { \"type\" : \"output\" , \"message\" : None , \"payload\" : gdb_mi_text }","title":"parse_response()"},{"location":"api/gdbmiparser/#pygdbmi.gdbmiparser.response_is_finished","text":"Return true if the gdb mi response is ending Parameters: Name Type Description Default gdb_mi_text str String output from gdb required Returns: Type Description bool True if gdb response is finished Source code in pygdbmi/gdbmiparser.py def response_is_finished ( gdb_mi_text : str ) -> bool : \"\"\"Return true if the gdb mi response is ending Args: gdb_mi_text: String output from gdb Returns: True if gdb response is finished \"\"\" if _GDB_MI_RESPONSE_FINISHED_RE . match ( gdb_mi_text ): return True else : return False","title":"response_is_finished()"},{"location":"api/iomanager/","text":"This module defines the IoManager class which manages I/O for file objects connected to an existing gdb process or pty. IoManager Source code in pygdbmi/IoManager.py class IoManager : def __init__ ( self , stdin : io . BufferedWriter , stdout : io . BufferedReader , stderr : Optional [ io . BufferedReader ], time_to_check_for_additional_output_sec = DEFAULT_TIME_TO_CHECK_FOR_ADDITIONAL_OUTPUT_SEC , ): \"\"\" Manage I/O for file objects created before calling this class This can be useful if the gdb process is managed elsewhere, or if a pty is used. \"\"\" self . stdin = stdin self . stdout = stdout self . stderr = stderr self . stdin_fileno = self . stdin . fileno () self . stdout_fileno = self . stdout . fileno () self . stderr_fileno = self . stderr . fileno () if self . stderr else - 1 self . read_list : List [ int ] = [] if self . stdout : self . read_list . append ( self . stdout_fileno ) self . write_list = [ self . stdin_fileno ] self . _incomplete_output : Dict [ str , Any ] = { \"stdout\" : None , \"stderr\" : None } self . time_to_check_for_additional_output_sec = ( time_to_check_for_additional_output_sec ) self . _allow_overwrite_timeout_times = ( self . time_to_check_for_additional_output_sec > 0 ) make_non_blocking ( self . stdout ) if self . stderr : make_non_blocking ( self . stderr ) def get_gdb_response ( self , timeout_sec : float = DEFAULT_GDB_TIMEOUT_SEC , raise_error_on_timeout = True ): \"\"\"Get response from GDB, and block while doing so. If GDB does not have any response ready to be read by timeout_sec, an exception is raised. Args: timeout_sec: Maximum time to wait for reponse. Must be >= 0. Will return after raise_error_on_timeout: Whether an exception should be raised if no response was found after timeout_sec Returns: List of parsed GDB responses, returned from gdbmiparser.parse_response, with the additional key 'stream' which is either 'stdout' or 'stderr' Raises: GdbTimeoutError: if response is not received within timeout_sec ValueError: if select returned unexpected file number \"\"\" if timeout_sec < 0 : logger . warning ( \"timeout_sec was negative, replacing with 0\" ) timeout_sec = 0 if USING_WINDOWS : retval = self . _get_responses_windows ( timeout_sec ) else : retval = self . _get_responses_unix ( timeout_sec ) if not retval and raise_error_on_timeout : raise GdbTimeoutError ( \"Did not get response from gdb after %s seconds\" % timeout_sec ) else : return retval def _get_responses_windows ( self , timeout_sec ): \"\"\"Get responses on windows. Assume no support for select and use a while loop.\"\"\" timeout_time_sec = time . time () + timeout_sec responses = [] while True : responses_list = [] try : self . stdout . flush () raw_output = self . stdout . readline () . replace ( b \" \\r \" , b \" \\n \" ) responses_list = self . _get_responses_list ( raw_output , \"stdout\" ) except IOError : pass try : self . stderr . flush () raw_output = self . stderr . readline () . replace ( b \" \\r \" , b \" \\n \" ) responses_list += self . _get_responses_list ( raw_output , \"stderr\" ) except IOError : pass responses += responses_list if timeout_sec == 0 : break elif responses_list and self . _allow_overwrite_timeout_times : timeout_time_sec = min ( time . time () + self . time_to_check_for_additional_output_sec , timeout_time_sec , ) elif time . time () > timeout_time_sec : break return responses def _get_responses_unix ( self , timeout_sec ): \"\"\"Get responses on unix-like system. Use select to wait for output.\"\"\" timeout_time_sec = time . time () + timeout_sec responses = [] while True : select_timeout = timeout_time_sec - time . time () if select_timeout <= 0 : select_timeout = 0 events , _ , _ = select . select ( self . read_list , [], [], select_timeout ) responses_list = None # to avoid infinite loop if using Python 2 for fileno in events : # new data is ready to read if fileno == self . stdout_fileno : self . stdout . flush () raw_output = self . stdout . read () stream = \"stdout\" elif fileno == self . stderr_fileno : self . stderr . flush () raw_output = self . stderr . read () stream = \"stderr\" else : raise ValueError ( \"Developer error. Got unexpected file number %d \" % fileno ) responses_list = self . _get_responses_list ( raw_output , stream ) responses += responses_list if timeout_sec == 0 : # just exit immediately break elif responses_list and self . _allow_overwrite_timeout_times : # update timeout time to potentially be closer to now to avoid lengthy wait times when nothing is being output by gdb timeout_time_sec = min ( time . time () + self . time_to_check_for_additional_output_sec , timeout_time_sec , ) elif time . time () > timeout_time_sec : break return responses def _get_responses_list ( self , raw_output : bytes , stream : str ) -> List [ Dict [ Any , Any ]]: \"\"\"Get parsed response list from string output Args: raw_output (unicode): gdb output to parse stream (str): either stdout or stderr \"\"\" responses : List [ Dict [ Any , Any ]] = [] ( _new_output , self . _incomplete_output [ stream ],) = _buffer_incomplete_responses ( raw_output , self . _incomplete_output . get ( stream ) ) if not _new_output : return responses response_list = list ( filter ( lambda x : x , _new_output . decode ( errors = \"replace\" ) . split ( \" \\n \" )) ) # remove blank lines # parse each response from gdb into a dict, and store in a list for response in response_list : if gdbmiparser . response_is_finished ( response ): pass else : parsed_response = gdbmiparser . parse_response ( response ) parsed_response [ \"stream\" ] = stream logger . debug ( \" %s \" , pformat ( parsed_response )) responses . append ( parsed_response ) return responses def write ( self , mi_cmd_to_write : Union [ str , List [ str ]], timeout_sec = DEFAULT_GDB_TIMEOUT_SEC , raise_error_on_timeout : bool = True , read_response : bool = True , ): \"\"\"Write to gdb process. Block while parsing responses from gdb for a maximum of timeout_sec. Args: mi_cmd_to_write: String to write to gdb. If list, it is joined by newlines. timeout_sec: Maximum number of seconds to wait for response before exiting. Must be >= 0. raise_error_on_timeout: If read_response is True, raise error if no response is received read_response: Block and read response. If there is a separate thread running, this can be false, and the reading thread read the output. Returns: List of parsed gdb responses if read_response is True, otherwise [] Raises: TypeError: if mi_cmd_to_write is not valid \"\"\" # self.verify_valid_gdb_subprocess() if timeout_sec < 0 : logger . warning ( \"timeout_sec was negative, replacing with 0\" ) timeout_sec = 0 # Ensure proper type of the mi command if isinstance ( mi_cmd_to_write , str ): mi_cmd_to_write_str = mi_cmd_to_write elif isinstance ( mi_cmd_to_write , list ): mi_cmd_to_write_str = \" \\n \" . join ( mi_cmd_to_write ) else : raise TypeError ( \"The gdb mi command must a be str or list. Got \" + str ( type ( mi_cmd_to_write )) ) logger . debug ( \"writing: %s \" , mi_cmd_to_write ) if not mi_cmd_to_write_str . endswith ( \" \\n \" ): mi_cmd_to_write_nl = mi_cmd_to_write_str + \" \\n \" else : mi_cmd_to_write_nl = mi_cmd_to_write_str if USING_WINDOWS : # select not implemented in windows for pipes # assume it's always ready outputready = [ self . stdin_fileno ] else : _ , outputready , _ = select . select ([], self . write_list , [], timeout_sec ) for fileno in outputready : if fileno == self . stdin_fileno : # ready to write self . stdin . write ( mi_cmd_to_write_nl . encode ()) # type: ignore # must flush, otherwise gdb won't realize there is data # to evaluate, and we won't get a response self . stdin . flush () # type: ignore else : logger . error ( \"got unexpected fileno %d \" % fileno ) if read_response is True : return self . get_gdb_response ( timeout_sec = timeout_sec , raise_error_on_timeout = raise_error_on_timeout ) else : return [] __init__ ( self , stdin , stdout , stderr , time_to_check_for_additional_output_sec = 0.2 ) special Manage I/O for file objects created before calling this class This can be useful if the gdb process is managed elsewhere, or if a pty is used. Source code in pygdbmi/IoManager.py def __init__ ( self , stdin : io . BufferedWriter , stdout : io . BufferedReader , stderr : Optional [ io . BufferedReader ], time_to_check_for_additional_output_sec = DEFAULT_TIME_TO_CHECK_FOR_ADDITIONAL_OUTPUT_SEC , ): \"\"\" Manage I/O for file objects created before calling this class This can be useful if the gdb process is managed elsewhere, or if a pty is used. \"\"\" self . stdin = stdin self . stdout = stdout self . stderr = stderr self . stdin_fileno = self . stdin . fileno () self . stdout_fileno = self . stdout . fileno () self . stderr_fileno = self . stderr . fileno () if self . stderr else - 1 self . read_list : List [ int ] = [] if self . stdout : self . read_list . append ( self . stdout_fileno ) self . write_list = [ self . stdin_fileno ] self . _incomplete_output : Dict [ str , Any ] = { \"stdout\" : None , \"stderr\" : None } self . time_to_check_for_additional_output_sec = ( time_to_check_for_additional_output_sec ) self . _allow_overwrite_timeout_times = ( self . time_to_check_for_additional_output_sec > 0 ) make_non_blocking ( self . stdout ) if self . stderr : make_non_blocking ( self . stderr ) get_gdb_response ( self , timeout_sec = 1 , raise_error_on_timeout = True ) Get response from GDB, and block while doing so. If GDB does not have any response ready to be read by timeout_sec, an exception is raised. Parameters: Name Type Description Default timeout_sec float Maximum time to wait for reponse. Must be >= 0. Will return after 1 raise_error_on_timeout Whether an exception should be raised if no response was found after timeout_sec True Returns: Type Description List of parsed GDB responses, returned from gdbmiparser.parse_response, with the additional key 'stream' which is either 'stdout' or 'stderr' Exceptions: Type Description GdbTimeoutError if response is not received within timeout_sec ValueError if select returned unexpected file number Source code in pygdbmi/IoManager.py def get_gdb_response ( self , timeout_sec : float = DEFAULT_GDB_TIMEOUT_SEC , raise_error_on_timeout = True ): \"\"\"Get response from GDB, and block while doing so. If GDB does not have any response ready to be read by timeout_sec, an exception is raised. Args: timeout_sec: Maximum time to wait for reponse. Must be >= 0. Will return after raise_error_on_timeout: Whether an exception should be raised if no response was found after timeout_sec Returns: List of parsed GDB responses, returned from gdbmiparser.parse_response, with the additional key 'stream' which is either 'stdout' or 'stderr' Raises: GdbTimeoutError: if response is not received within timeout_sec ValueError: if select returned unexpected file number \"\"\" if timeout_sec < 0 : logger . warning ( \"timeout_sec was negative, replacing with 0\" ) timeout_sec = 0 if USING_WINDOWS : retval = self . _get_responses_windows ( timeout_sec ) else : retval = self . _get_responses_unix ( timeout_sec ) if not retval and raise_error_on_timeout : raise GdbTimeoutError ( \"Did not get response from gdb after %s seconds\" % timeout_sec ) else : return retval write ( self , mi_cmd_to_write , timeout_sec = 1 , raise_error_on_timeout = True , read_response = True ) Write to gdb process. Block while parsing responses from gdb for a maximum of timeout_sec. Parameters: Name Type Description Default mi_cmd_to_write Union[str, List[str]] String to write to gdb. If list, it is joined by newlines. required timeout_sec Maximum number of seconds to wait for response before exiting. Must be >= 0. 1 raise_error_on_timeout bool If read_response is True, raise error if no response is received True read_response bool Block and read response. If there is a separate thread running, this can be false, and the reading thread read the output. True Returns: Type Description List of parsed gdb responses if read_response is True, otherwise [] Exceptions: Type Description TypeError if mi_cmd_to_write is not valid Source code in pygdbmi/IoManager.py def write ( self , mi_cmd_to_write : Union [ str , List [ str ]], timeout_sec = DEFAULT_GDB_TIMEOUT_SEC , raise_error_on_timeout : bool = True , read_response : bool = True , ): \"\"\"Write to gdb process. Block while parsing responses from gdb for a maximum of timeout_sec. Args: mi_cmd_to_write: String to write to gdb. If list, it is joined by newlines. timeout_sec: Maximum number of seconds to wait for response before exiting. Must be >= 0. raise_error_on_timeout: If read_response is True, raise error if no response is received read_response: Block and read response. If there is a separate thread running, this can be false, and the reading thread read the output. Returns: List of parsed gdb responses if read_response is True, otherwise [] Raises: TypeError: if mi_cmd_to_write is not valid \"\"\" # self.verify_valid_gdb_subprocess() if timeout_sec < 0 : logger . warning ( \"timeout_sec was negative, replacing with 0\" ) timeout_sec = 0 # Ensure proper type of the mi command if isinstance ( mi_cmd_to_write , str ): mi_cmd_to_write_str = mi_cmd_to_write elif isinstance ( mi_cmd_to_write , list ): mi_cmd_to_write_str = \" \\n \" . join ( mi_cmd_to_write ) else : raise TypeError ( \"The gdb mi command must a be str or list. Got \" + str ( type ( mi_cmd_to_write )) ) logger . debug ( \"writing: %s \" , mi_cmd_to_write ) if not mi_cmd_to_write_str . endswith ( \" \\n \" ): mi_cmd_to_write_nl = mi_cmd_to_write_str + \" \\n \" else : mi_cmd_to_write_nl = mi_cmd_to_write_str if USING_WINDOWS : # select not implemented in windows for pipes # assume it's always ready outputready = [ self . stdin_fileno ] else : _ , outputready , _ = select . select ([], self . write_list , [], timeout_sec ) for fileno in outputready : if fileno == self . stdin_fileno : # ready to write self . stdin . write ( mi_cmd_to_write_nl . encode ()) # type: ignore # must flush, otherwise gdb won't realize there is data # to evaluate, and we won't get a response self . stdin . flush () # type: ignore else : logger . error ( \"got unexpected fileno %d \" % fileno ) if read_response is True : return self . get_gdb_response ( timeout_sec = timeout_sec , raise_error_on_timeout = raise_error_on_timeout ) else : return [] make_non_blocking ( file_obj ) make file object non-blocking Windows doesn't have the fcntl module, but someone on stack overflow supplied this code as an answer, and it works http://stackoverflow.com/a/34504971/2893090 Source code in pygdbmi/IoManager.py def make_non_blocking ( file_obj : io . IOBase ): \"\"\"make file object non-blocking Windows doesn't have the fcntl module, but someone on stack overflow supplied this code as an answer, and it works http://stackoverflow.com/a/34504971/2893090\"\"\" if USING_WINDOWS : LPDWORD = POINTER ( DWORD ) PIPE_NOWAIT = wintypes . DWORD ( 0x00000001 ) SetNamedPipeHandleState = windll . kernel32 . SetNamedPipeHandleState SetNamedPipeHandleState . argtypes = [ HANDLE , LPDWORD , LPDWORD , LPDWORD ] SetNamedPipeHandleState . restype = BOOL h = msvcrt . get_osfhandle ( file_obj . fileno ()) # type: ignore res = windll . kernel32 . SetNamedPipeHandleState ( h , byref ( PIPE_NOWAIT ), None , None ) if res == 0 : raise ValueError ( WinError ()) else : # Set the file status flag (F_SETFL) on the pipes to be non-blocking # so we can attempt to read from a pipe with no new data without locking # the program up fcntl . fcntl ( file_obj , fcntl . F_SETFL , os . O_NONBLOCK )","title":"iomanager"},{"location":"api/iomanager/#pygdbmi.IoManager.IoManager","text":"Source code in pygdbmi/IoManager.py class IoManager : def __init__ ( self , stdin : io . BufferedWriter , stdout : io . BufferedReader , stderr : Optional [ io . BufferedReader ], time_to_check_for_additional_output_sec = DEFAULT_TIME_TO_CHECK_FOR_ADDITIONAL_OUTPUT_SEC , ): \"\"\" Manage I/O for file objects created before calling this class This can be useful if the gdb process is managed elsewhere, or if a pty is used. \"\"\" self . stdin = stdin self . stdout = stdout self . stderr = stderr self . stdin_fileno = self . stdin . fileno () self . stdout_fileno = self . stdout . fileno () self . stderr_fileno = self . stderr . fileno () if self . stderr else - 1 self . read_list : List [ int ] = [] if self . stdout : self . read_list . append ( self . stdout_fileno ) self . write_list = [ self . stdin_fileno ] self . _incomplete_output : Dict [ str , Any ] = { \"stdout\" : None , \"stderr\" : None } self . time_to_check_for_additional_output_sec = ( time_to_check_for_additional_output_sec ) self . _allow_overwrite_timeout_times = ( self . time_to_check_for_additional_output_sec > 0 ) make_non_blocking ( self . stdout ) if self . stderr : make_non_blocking ( self . stderr ) def get_gdb_response ( self , timeout_sec : float = DEFAULT_GDB_TIMEOUT_SEC , raise_error_on_timeout = True ): \"\"\"Get response from GDB, and block while doing so. If GDB does not have any response ready to be read by timeout_sec, an exception is raised. Args: timeout_sec: Maximum time to wait for reponse. Must be >= 0. Will return after raise_error_on_timeout: Whether an exception should be raised if no response was found after timeout_sec Returns: List of parsed GDB responses, returned from gdbmiparser.parse_response, with the additional key 'stream' which is either 'stdout' or 'stderr' Raises: GdbTimeoutError: if response is not received within timeout_sec ValueError: if select returned unexpected file number \"\"\" if timeout_sec < 0 : logger . warning ( \"timeout_sec was negative, replacing with 0\" ) timeout_sec = 0 if USING_WINDOWS : retval = self . _get_responses_windows ( timeout_sec ) else : retval = self . _get_responses_unix ( timeout_sec ) if not retval and raise_error_on_timeout : raise GdbTimeoutError ( \"Did not get response from gdb after %s seconds\" % timeout_sec ) else : return retval def _get_responses_windows ( self , timeout_sec ): \"\"\"Get responses on windows. Assume no support for select and use a while loop.\"\"\" timeout_time_sec = time . time () + timeout_sec responses = [] while True : responses_list = [] try : self . stdout . flush () raw_output = self . stdout . readline () . replace ( b \" \\r \" , b \" \\n \" ) responses_list = self . _get_responses_list ( raw_output , \"stdout\" ) except IOError : pass try : self . stderr . flush () raw_output = self . stderr . readline () . replace ( b \" \\r \" , b \" \\n \" ) responses_list += self . _get_responses_list ( raw_output , \"stderr\" ) except IOError : pass responses += responses_list if timeout_sec == 0 : break elif responses_list and self . _allow_overwrite_timeout_times : timeout_time_sec = min ( time . time () + self . time_to_check_for_additional_output_sec , timeout_time_sec , ) elif time . time () > timeout_time_sec : break return responses def _get_responses_unix ( self , timeout_sec ): \"\"\"Get responses on unix-like system. Use select to wait for output.\"\"\" timeout_time_sec = time . time () + timeout_sec responses = [] while True : select_timeout = timeout_time_sec - time . time () if select_timeout <= 0 : select_timeout = 0 events , _ , _ = select . select ( self . read_list , [], [], select_timeout ) responses_list = None # to avoid infinite loop if using Python 2 for fileno in events : # new data is ready to read if fileno == self . stdout_fileno : self . stdout . flush () raw_output = self . stdout . read () stream = \"stdout\" elif fileno == self . stderr_fileno : self . stderr . flush () raw_output = self . stderr . read () stream = \"stderr\" else : raise ValueError ( \"Developer error. Got unexpected file number %d \" % fileno ) responses_list = self . _get_responses_list ( raw_output , stream ) responses += responses_list if timeout_sec == 0 : # just exit immediately break elif responses_list and self . _allow_overwrite_timeout_times : # update timeout time to potentially be closer to now to avoid lengthy wait times when nothing is being output by gdb timeout_time_sec = min ( time . time () + self . time_to_check_for_additional_output_sec , timeout_time_sec , ) elif time . time () > timeout_time_sec : break return responses def _get_responses_list ( self , raw_output : bytes , stream : str ) -> List [ Dict [ Any , Any ]]: \"\"\"Get parsed response list from string output Args: raw_output (unicode): gdb output to parse stream (str): either stdout or stderr \"\"\" responses : List [ Dict [ Any , Any ]] = [] ( _new_output , self . _incomplete_output [ stream ],) = _buffer_incomplete_responses ( raw_output , self . _incomplete_output . get ( stream ) ) if not _new_output : return responses response_list = list ( filter ( lambda x : x , _new_output . decode ( errors = \"replace\" ) . split ( \" \\n \" )) ) # remove blank lines # parse each response from gdb into a dict, and store in a list for response in response_list : if gdbmiparser . response_is_finished ( response ): pass else : parsed_response = gdbmiparser . parse_response ( response ) parsed_response [ \"stream\" ] = stream logger . debug ( \" %s \" , pformat ( parsed_response )) responses . append ( parsed_response ) return responses def write ( self , mi_cmd_to_write : Union [ str , List [ str ]], timeout_sec = DEFAULT_GDB_TIMEOUT_SEC , raise_error_on_timeout : bool = True , read_response : bool = True , ): \"\"\"Write to gdb process. Block while parsing responses from gdb for a maximum of timeout_sec. Args: mi_cmd_to_write: String to write to gdb. If list, it is joined by newlines. timeout_sec: Maximum number of seconds to wait for response before exiting. Must be >= 0. raise_error_on_timeout: If read_response is True, raise error if no response is received read_response: Block and read response. If there is a separate thread running, this can be false, and the reading thread read the output. Returns: List of parsed gdb responses if read_response is True, otherwise [] Raises: TypeError: if mi_cmd_to_write is not valid \"\"\" # self.verify_valid_gdb_subprocess() if timeout_sec < 0 : logger . warning ( \"timeout_sec was negative, replacing with 0\" ) timeout_sec = 0 # Ensure proper type of the mi command if isinstance ( mi_cmd_to_write , str ): mi_cmd_to_write_str = mi_cmd_to_write elif isinstance ( mi_cmd_to_write , list ): mi_cmd_to_write_str = \" \\n \" . join ( mi_cmd_to_write ) else : raise TypeError ( \"The gdb mi command must a be str or list. Got \" + str ( type ( mi_cmd_to_write )) ) logger . debug ( \"writing: %s \" , mi_cmd_to_write ) if not mi_cmd_to_write_str . endswith ( \" \\n \" ): mi_cmd_to_write_nl = mi_cmd_to_write_str + \" \\n \" else : mi_cmd_to_write_nl = mi_cmd_to_write_str if USING_WINDOWS : # select not implemented in windows for pipes # assume it's always ready outputready = [ self . stdin_fileno ] else : _ , outputready , _ = select . select ([], self . write_list , [], timeout_sec ) for fileno in outputready : if fileno == self . stdin_fileno : # ready to write self . stdin . write ( mi_cmd_to_write_nl . encode ()) # type: ignore # must flush, otherwise gdb won't realize there is data # to evaluate, and we won't get a response self . stdin . flush () # type: ignore else : logger . error ( \"got unexpected fileno %d \" % fileno ) if read_response is True : return self . get_gdb_response ( timeout_sec = timeout_sec , raise_error_on_timeout = raise_error_on_timeout ) else : return []","title":"IoManager"},{"location":"api/iomanager/#pygdbmi.IoManager.IoManager.__init__","text":"Manage I/O for file objects created before calling this class This can be useful if the gdb process is managed elsewhere, or if a pty is used. Source code in pygdbmi/IoManager.py def __init__ ( self , stdin : io . BufferedWriter , stdout : io . BufferedReader , stderr : Optional [ io . BufferedReader ], time_to_check_for_additional_output_sec = DEFAULT_TIME_TO_CHECK_FOR_ADDITIONAL_OUTPUT_SEC , ): \"\"\" Manage I/O for file objects created before calling this class This can be useful if the gdb process is managed elsewhere, or if a pty is used. \"\"\" self . stdin = stdin self . stdout = stdout self . stderr = stderr self . stdin_fileno = self . stdin . fileno () self . stdout_fileno = self . stdout . fileno () self . stderr_fileno = self . stderr . fileno () if self . stderr else - 1 self . read_list : List [ int ] = [] if self . stdout : self . read_list . append ( self . stdout_fileno ) self . write_list = [ self . stdin_fileno ] self . _incomplete_output : Dict [ str , Any ] = { \"stdout\" : None , \"stderr\" : None } self . time_to_check_for_additional_output_sec = ( time_to_check_for_additional_output_sec ) self . _allow_overwrite_timeout_times = ( self . time_to_check_for_additional_output_sec > 0 ) make_non_blocking ( self . stdout ) if self . stderr : make_non_blocking ( self . stderr )","title":"__init__()"},{"location":"api/iomanager/#pygdbmi.IoManager.IoManager.get_gdb_response","text":"Get response from GDB, and block while doing so. If GDB does not have any response ready to be read by timeout_sec, an exception is raised. Parameters: Name Type Description Default timeout_sec float Maximum time to wait for reponse. Must be >= 0. Will return after 1 raise_error_on_timeout Whether an exception should be raised if no response was found after timeout_sec True Returns: Type Description List of parsed GDB responses, returned from gdbmiparser.parse_response, with the additional key 'stream' which is either 'stdout' or 'stderr' Exceptions: Type Description GdbTimeoutError if response is not received within timeout_sec ValueError if select returned unexpected file number Source code in pygdbmi/IoManager.py def get_gdb_response ( self , timeout_sec : float = DEFAULT_GDB_TIMEOUT_SEC , raise_error_on_timeout = True ): \"\"\"Get response from GDB, and block while doing so. If GDB does not have any response ready to be read by timeout_sec, an exception is raised. Args: timeout_sec: Maximum time to wait for reponse. Must be >= 0. Will return after raise_error_on_timeout: Whether an exception should be raised if no response was found after timeout_sec Returns: List of parsed GDB responses, returned from gdbmiparser.parse_response, with the additional key 'stream' which is either 'stdout' or 'stderr' Raises: GdbTimeoutError: if response is not received within timeout_sec ValueError: if select returned unexpected file number \"\"\" if timeout_sec < 0 : logger . warning ( \"timeout_sec was negative, replacing with 0\" ) timeout_sec = 0 if USING_WINDOWS : retval = self . _get_responses_windows ( timeout_sec ) else : retval = self . _get_responses_unix ( timeout_sec ) if not retval and raise_error_on_timeout : raise GdbTimeoutError ( \"Did not get response from gdb after %s seconds\" % timeout_sec ) else : return retval","title":"get_gdb_response()"},{"location":"api/iomanager/#pygdbmi.IoManager.IoManager.write","text":"Write to gdb process. Block while parsing responses from gdb for a maximum of timeout_sec. Parameters: Name Type Description Default mi_cmd_to_write Union[str, List[str]] String to write to gdb. If list, it is joined by newlines. required timeout_sec Maximum number of seconds to wait for response before exiting. Must be >= 0. 1 raise_error_on_timeout bool If read_response is True, raise error if no response is received True read_response bool Block and read response. If there is a separate thread running, this can be false, and the reading thread read the output. True Returns: Type Description List of parsed gdb responses if read_response is True, otherwise [] Exceptions: Type Description TypeError if mi_cmd_to_write is not valid Source code in pygdbmi/IoManager.py def write ( self , mi_cmd_to_write : Union [ str , List [ str ]], timeout_sec = DEFAULT_GDB_TIMEOUT_SEC , raise_error_on_timeout : bool = True , read_response : bool = True , ): \"\"\"Write to gdb process. Block while parsing responses from gdb for a maximum of timeout_sec. Args: mi_cmd_to_write: String to write to gdb. If list, it is joined by newlines. timeout_sec: Maximum number of seconds to wait for response before exiting. Must be >= 0. raise_error_on_timeout: If read_response is True, raise error if no response is received read_response: Block and read response. If there is a separate thread running, this can be false, and the reading thread read the output. Returns: List of parsed gdb responses if read_response is True, otherwise [] Raises: TypeError: if mi_cmd_to_write is not valid \"\"\" # self.verify_valid_gdb_subprocess() if timeout_sec < 0 : logger . warning ( \"timeout_sec was negative, replacing with 0\" ) timeout_sec = 0 # Ensure proper type of the mi command if isinstance ( mi_cmd_to_write , str ): mi_cmd_to_write_str = mi_cmd_to_write elif isinstance ( mi_cmd_to_write , list ): mi_cmd_to_write_str = \" \\n \" . join ( mi_cmd_to_write ) else : raise TypeError ( \"The gdb mi command must a be str or list. Got \" + str ( type ( mi_cmd_to_write )) ) logger . debug ( \"writing: %s \" , mi_cmd_to_write ) if not mi_cmd_to_write_str . endswith ( \" \\n \" ): mi_cmd_to_write_nl = mi_cmd_to_write_str + \" \\n \" else : mi_cmd_to_write_nl = mi_cmd_to_write_str if USING_WINDOWS : # select not implemented in windows for pipes # assume it's always ready outputready = [ self . stdin_fileno ] else : _ , outputready , _ = select . select ([], self . write_list , [], timeout_sec ) for fileno in outputready : if fileno == self . stdin_fileno : # ready to write self . stdin . write ( mi_cmd_to_write_nl . encode ()) # type: ignore # must flush, otherwise gdb won't realize there is data # to evaluate, and we won't get a response self . stdin . flush () # type: ignore else : logger . error ( \"got unexpected fileno %d \" % fileno ) if read_response is True : return self . get_gdb_response ( timeout_sec = timeout_sec , raise_error_on_timeout = raise_error_on_timeout ) else : return []","title":"write()"},{"location":"api/iomanager/#pygdbmi.IoManager.make_non_blocking","text":"make file object non-blocking Windows doesn't have the fcntl module, but someone on stack overflow supplied this code as an answer, and it works http://stackoverflow.com/a/34504971/2893090 Source code in pygdbmi/IoManager.py def make_non_blocking ( file_obj : io . IOBase ): \"\"\"make file object non-blocking Windows doesn't have the fcntl module, but someone on stack overflow supplied this code as an answer, and it works http://stackoverflow.com/a/34504971/2893090\"\"\" if USING_WINDOWS : LPDWORD = POINTER ( DWORD ) PIPE_NOWAIT = wintypes . DWORD ( 0x00000001 ) SetNamedPipeHandleState = windll . kernel32 . SetNamedPipeHandleState SetNamedPipeHandleState . argtypes = [ HANDLE , LPDWORD , LPDWORD , LPDWORD ] SetNamedPipeHandleState . restype = BOOL h = msvcrt . get_osfhandle ( file_obj . fileno ()) # type: ignore res = windll . kernel32 . SetNamedPipeHandleState ( h , byref ( PIPE_NOWAIT ), None , None ) if res == 0 : raise ValueError ( WinError ()) else : # Set the file status flag (F_SETFL) on the pipes to be non-blocking # so we can attempt to read from a pipe with no new data without locking # the program up fcntl . fcntl ( file_obj , fcntl . F_SETFL , os . O_NONBLOCK )","title":"make_non_blocking()"}]}